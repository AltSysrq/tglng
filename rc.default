#long-mode#
bind section-command (
bind section-command [
bind section-command {
bind close-brace     }
bind close-bracket   ]
bind close-paren     )
bind read-reg        r
bind read-reg        $
bind write-reg       @
bind num-add         +
bind num-sub         -
bind num-mul         *
bind num-div         /
bind num-mod         %
bind num-slt         <
bind num-sgt         >
bind logical-or      |
bind logical-and     &
bind logical-not     !

bind if              i
bind false-coalesce  I
bind for-integer     f
bind for-int-print   F
bind for-each        e
bind for-each-print  E
bind while           w

ensemble-new         string-ops
bind string-ops      s
bind str-equ         =
bind str-ix          c
bind str-is          ~
ensemble-bind string-ops str-slt        <
ensemble-bind string-ops str-sgt        >
ensemble-bind string-ops str-str        s
ensemble-bind string-ops str-len        #
ensemble-bind string-ops str-toupper    U
ensemble-bind string-ops str-tolower    L
ensemble-bind string-ops str-totitle    T
ensemble-bind string-ops str-tosent     S
ensemble-bind string-ops str-tocamel    C
ensemble-bind string-ops str-topascal   P
ensemble-bind string-ops str-toscream   !
ensemble-bind string-ops str-tocstyle   _
ensemble-bind string-ops str-tocaspal   E
ensemble-bind string-ops str-tolisp     I
ensemble-bind string-ops str-tocobol    X

bind rx-match-inline R
bind rx-repl-inline  S

ensemble-new secondary-commands
bind secondary-commands x
ensemble-new secondary-numeric-ops
ensemble-bind secondary-commands secondary-numeric-ops n
ensemble-bind secondary-numeric-ops num-equ =
ensemble-new other-commands
ensemble-bind secondary-commands other-commands o
ensemble-bind other-commands logical-xor r
ensemble-bind secondary-commands lambda \
bind lambda λ

defun ch-escape(s) (
  default-tokeniser([\`$s`], {+e}))

defun tokfmt-csv {+_ld,t""e}
defun tokfmt-tcl {+!t""e-b()}
defun tokfmt-json {+!t""ed:d,-b()}

defun basename(f) (
  ignore R:([^/]+)/?$:$f
  $1)

defun parent-directory(f) (
  if (R:^/+[^/]+$:$f) {/}
  if (R:/+[^/]+/*$:$f) $< {.}
)

defun file-extension(f) (
  ignore R:[^/]\.([^./]+)$:$f
  $1)

defun sort(ic) (
  if (< list-len($i) 2) $i (
    if (= {} $c) (@c{str-slt})
    @p list-ix($i, random(list-len($i)))
    @l list-filter[r](λ(x) call $c($x, $p), $i)
    @r list-filter[p](λ(x) call $c($p, $x), $r)
    @l call {sort} ($l, $c)
    @r call {sort} ($r, $c)
    list-flatten(list($l, $p, $r))
  )
)

defun trim-trailing-lf(s) (
  str-ix 0
    +0(if (= (str-ix -1 $s) (ch-escape({n})))
     {-2} {-1}) $s)

defun pwd() (
  trim-trailing-lf(exec({pwd})))

defun list-reverse(L) (
  @l {}
  for-each i $L (@l (list-escape($i) { } $l))
  $l)

ignore {
  BEGIN: Default startup.
  First, read the user's .tglng file if possible.
}
@u read[s]([`getenv({HOME})/.tglng`])
ignore if $s (eval($u))

ignore {
  Get lists of permitted and known secondary configs.
}
@k read[_]([`getenv({HOME})/.tglng_known`])
@p read[_]([`getenv({HOME})/.tglng_permitted`])
@c {}

ignore {
  List secondary configurations, starting in pwd.
}
@d pwd()
@D {}
ignore {List parent directories (up to root or home), then reverse so we go
  top-down.}
while (& != $d {/} != $d getenv({HOME})) (
  @D list-append($D, $d)
  @d parent-directory($d)
)
@D list-reverse($D)

for-each d $D (
  @u read[s]([`$d/.tglng`])
  if $s (
    ignore { Is it permitted and/or known? }
    @P 0
    @K 0
    for-each x $p (@P |$P =$d$x)
    for-each x $k (@K |$K =$d$x)
    if $P (
      ignore {Permitted, safe to eval.}
      ignore eval($u)
    ) (
      if $K (
        ignore {Not permitted but known, don't bother the user.}
      ) (
        ignore {Not known, not safe to eval, but let the user know it's there.}
        warn([Directory `$d contains a .tglng, but is not permitted.`])
        warn([Add `$d to ~/.tglng_permitted if you trust this script.`])
        ignore {Mark as known}
        ignore append([`getenv({HOME})/.tglng_known`], (ch-escape({n})
                                                        list-escape($d)))
      )
    )
  )
)
