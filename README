TglNG -- Text Generation Language, Next Generation

----

TglNG (pronounced "tag-along") is an interpreter for terse, ad-hoc text
generation programs. It is made to fill the same role as Tgl, taking into
account lessons learned from the latter.

BASIC CONCEPTS

Every TglNG program consists of a command tree. A command is simply a reference
to code which results in a string value; it generally also tracks other
commands which it uses for inputs, thus forming the aforementioned tree. After
parsing, the top-most command is executed, and its result is written to
stdout. This stands in contrast to Tgl, which required the user to manually
write to standard output.

Each command defines its own way of interpreting the characters which follow it
in the input; this allows for significantly more expressiveness than was
possible in Tgl.

CHARACTERS and STRINGS

TglNG defines a "character" to be a single wchar_t. On systems like most
GNU/Linux systems, this is always correct. However, on systems (like Windows)
where wchar_t is used to store UTF-16, TglNG will not handle surrogate pairs,
instead assuming the text is encoded in UCS-2. This is generally not an issue,
unless you want to use Egyptian Heiroglyphics.

A "string" is any number of "character"s, with no constrains placed on the
characters within.

A "name-char" is any character which is not considered to be whitespace
according to the current locale.

PARSING

All input code is parsed before execution. When a command is parsed, the
command is provided with two inputs:
o The command tree which precedes the command being parsed.
o The characters from the command to the end of the string.
If the command parses successfully, it results in:
o The new command-tree which represents the combined inputs.
o The characters which remain to be parsed.

To make use of TglNG as fluid as possible, there are four modes of command
parsing:
o Verbatim mode. Every individual character is recognised as the self-insert
  command.
o Literal mode. The configured escape character (default `) is recognised as
  the single-command command, and all others are the self-insert command.
o Command mode. Every character is looked up as the command bound to it, except
  for the escape character, which is assumed to be no-op, and space/control
  characters, which are implicitly the no-op command.
o Long mode. Used when the long-mode flag is set and command mode would
  otherwise be used. Alphanumeric characters are interpreted as long-mode-cmd;
  all others as if Command mode were in use.

EXECUTION

When parsing completes successfully, the top-most command is executed and its
result printed, if successful. While TglNG tries to be more declarative in
nature --- such that execution order would not matter --- it does have some
imperative features. Therefore, most commands will perform strict left-to-right
evaluation when not dictated otherwise by the user.

REGISTERS

The TglNG interpreter allows the user to define any number of registers, each
bound to a single name-char. At any given time, a defined register holds
exactly one arbitrary string. Attempting to read from an undefined register is
an error.

NUMBERS

Any string matching the following regular expression is considered a number by
TglNG (not case-sensitive):
  \s*[+-]?([0-9]+|0x[0-9A-F]+|0o[0-7]+|0b[01]+)\s*

The usual interpretations apply; 0x indicates hexadecimal, 0o octal, and 0b
binary. The interpreter uses the C int type to store integers, so be wary of
overflows when performing arithmetic on large values.

BOOLEANS

A string is considered boolean false if it is the empty string or if it is a
valid integer representation of zero. Any other string is considered true.

STANDARD ARGUMENTS

While every command defines its own syntax, most of them share the same syntax
for parsing their arguments. In all cases, leading whitespace is skipped.

Numeric (N):
Identified by a digit, '+', or '-'. Reads in characters which constitute a
single integer (see the NUMBERS section) until a non-number character, or a
sign beyond the first character, is encountered.

Register (R):
Not identifiable; when multiple argument types are possible, Register is always
the last one tried. A register argument is simply a single name-char.

Command (C):
Not identifiable; when multiple argument types are possible, Command is always
the last one tried. A command arguemnt is a single command which is parsed in
its entirety.

Section (S):
Identified by one of the characters described below. A section refers to one or
two "captured" command trees. Each section has a left and right part; the left
part, if present, is the command tree to the right of the command being parsed,
and is thus not sensitive to the parsing mode of the section argument; the
right part, if present, is the result of parsing text to the right of the
section argument.

Arithmetic (A):
An arithmetic argument is either a numeric which does not start with a plus
sign, or a command.

Character (H):
A single character.

The section argument proper is a single character:
< Captures only the left command tree for this section.
> Captures all text to the right of the argument and parses it in literal
  mode.
: Parses one command to the right in command mode, and uses that as the right
  part of the section.
| Captures the left command tree as well as all text to the right of the
  argument; the right part is parsed in literal mode.
( Captures text to the right of the command, parsing it in comand mode, until a
  close-paren ) command is parsed at top-level.
[ Captures text to the right of the command, parsing it in literal mode, until
  a close-bracket ] command is parsed at top-level.
{ Captures text to the right of the command, parsing it in verbatim mode. Stops
  when the matching } (allowing braces, but no other characters, to nest) is
  found.
$ Uses the next name-char after the argument as a register name. The section's
  right-hand part is a command-tree which results in that register's content.

BUILTIN COMMANDS

Every command has a "long name", which is (by convention) a string describing
what the command does, words separated by hyphens. Commands may be bound to
"short names", which are single name-chars recognised by the parser. Unless
otherwise noted, the short name for a command listed below is simply assigned
in the defaul configuration.

Each command description specifies its arguments in up to three ways:
o Types: A single character indicating the standard argument type.
o Regexen: A regex of characters that will match, enclosed in /slashes/.
o Literal characters: A string inside "double quotes" which matches the
  character(s) exactly.

If a colon and a name follows an arument specifier, whatever matched the
argument is named by that name in the command description. If an equals and a
value follows a name, the value is the default if the argument is
omitted. Unquoted parentheses and brackets indicate grouping; brackets
additionally indicate optionality. An unquoted pipe indcates different
possibilities. When the long-mode flag is set, whitespace is also accepted for
single-character-terminated strings (eg, in bind).

Unless otherwise noted, any command's result is implicitly appended to the
result of the left-hand code, unless the left-hand is captured by a
section. Commands whose long name is followed by a λ can be used as functions
(see the FUNCTIONS section for information on functions and what "standard
function syntax" means).

long-command    #       /[^#]+#/:command-name
Executes command-name (excluding the tailing '#') by looking it up by its long
name and parsing the matching command as if the trailing '#' were its short
name. The short name of this command is hard-wired, since it would otherwise be
impossible to call any commands.

self-insert     (none)  (none)
Results in a one-character string which is the same as the apparent short name
of the command.

no-op           (none)  (none)
Results in the empty string.

section-command {[(      ...:commands
Treats its own character as a section argument, and executes that section.

close-paren     )       (none)
Terminates parsing due to closing parenthesis.

close-bracket   ]       (none)
Terminates parsing due to closing bracket.

close-brace     }       (none)
Terminates parsing due to closing brace.

if              i       S:condition S:then [S:else={}]
If the result of condition is true, return the result of evaluating then;
otherwise, return the result of evaluating else (default an empty string).

false-coalesce  I       S:test S:otherwise
If the result of test is true, result in that; otherwise, evaluate otherwise
and use its result.

for-integer     f       [A:limit=10 [R:reg=i [A:init=0 [A:inc=auto]]]] S:body

for-int-print   F       [A:limit=10 [R:reg=i [A:init=0 [A:inc=auto]]]] S:body

for-each        e       [/[a-zA-Z0-9]+/:regs="p"]
                        ["%" /[^%]+%/:preprocessor="default-tokeniser-pre"]
                        ["#" /[^#]+#/:tokeniser="default-tokeniser"]
                        [("+" | "-") H...:options=""]
                        (S:list S:body | "?" S:body S:list)

for-each-print  E       (same syntax as for-each)

read-reg        r       R:register
Evaluates to the current content of register.

write-reg       @       R:register A:value
Evaluates value and sets register to its result. Results in the empty string.

unset-reg       (none)  R:register
Deletes the value associated with register.

num-add λ       +       A A
num-sub λ       -       A A
num-mul λ       *       A A
num-div λ       /       A A
num-mod λ       %       A A
Perform the respective arithmetic operations on their arguments. Division and
modulus fail if the RHS is zero.

num-equ λ       xn=     A A
num-neq λ       (none)  A A
num-slt λ       <       A A
num-sgt λ       >       A A
num-leq λ       (none)  A A
num-geq λ       (none)  A A
Perform numeric comparisons on their arguments.

logical-and λ   &       A A
logical-or λ    |       A A
logical-xor λ   xor     A A
Logically combines the boolean values of the LHS and RHS. The RHS is only
evaluated if necessary. Note that, in function form, this short-circuiting has
no effect since all parameters are evaluated before the function is invoked.

logical-not λ   !       A
Results in the boolean negation of the result of its arguments.

str-equ λ       =       A A
str-slt λ       s<      A A
str-sgt λ       s>      A A
str-str λ       ss      A A
Perform case-sensitive string comparisons on their arguments.

str-ix          c       A:begin [A:end | "." A:length] S:string
Results in the contents of the result of evaluating string, between begin
(inclusive) and either end or (begin+length), whichever is specified
(exclusive). If both end and length are omitted, end is set to
(begin+1). Negative indices for begin are relative to the length of the string,
and for end/(begin+length) to one plus the length of the string. Indices are
clamped to the string boundaries, and end to begin.

str-is          ~       H:type A:string
Tests whether the string is of the class indicated by H (multiple characters
indicate multiple characters which each mean the same thing):
  l   Lowercase UNICODE         L (negated)
  o   Lowercase ASCII           O (negated)
  u   Uppercase UNICODE         U (negated)
  v   Uppercase ASCII           V (negated)
  a   Alphabetic UNICODE        A (negated)
  b   Alphabetic ASCII          B (negated)
  n   Alphanumeric UNICODE      N (negated)
  m   Alphanumeric ASCII        M (negated)
  \   ASCII Control Character   ~ (negated)
  0   ASCII digit               9 (negated)
  x   ASCII hexit               X (negated)
  .p  UNICODE Punctuation       :P (negated)
  ,q  ASCII Punctuation         ;Q (negated)
  _s  UNICODE Whitespace        #S (negated)
  g   UNICODE Graphical         G (negated)
  h   ASCII Graphical           H (negated)
  r   UNICODE Printing          R (negated)
  t   ASCII Printing            T (negated)

str-toupper λ   sU      A
str-tolower λ   sL      A
Transform the input string into upper or lowercase, according to the current
locale. The length of the string is unchanged ("ß" does not become "ẞ" or
"SS"). Turks beware!

str-totitle λ   sT      A
str-tosent  λ   sS      A
str-tocamel λ   sC      A
str-topascal λ  sP      A
str-toscream λ  s!      A
str-tocstyle λ  s_      A
str-tocaspal λ  sE      A
str-tolisp λ    sI      A
str-tocobol λ   sX      A
Performs "magic" case and convention conversion. These commands attempt to
transform the input string into a string matching the given case and delimiter
convention indicated:
  title    This Is A Title
  sent     This is a sentence
  camel    thisIsCamelCase
  pascal   ThisIsPascalCase
  scream   THESE_ARE_SCREAMING_CAPS
  cstyle   c_style_identifier
  caspal   This_Is_Caspal_Style
  lisp     i-am-lispy
  cobol    I-HATE-MY-LIFE
As with str-toupper and str-tolower, case conversions are performed according
to the current locale, so if your locale is Turkish you probably want to run
TglNG under some other locale (eg, "en_US.UTF-8") if not working with actual
Turkish text.

str-len λ       s#      A
Results in the length of the result of its argument.

default-tokeniser λ     default function syntax
                        (token remainder <- remainder options)
default-tokeniser-pre λ default function syntax
                        (remainder options <- remainder options)

defun           (none)  /[^#]+#/:long-name
                        [":" H:short-name = (none)]
                        ["[" /[^\]]*/:outvars="" "]"]
                        ["(" /[^\)]*/:invars="" ")"]
                        [/[a-zA-Z0-9]+/:opts=""]
                        S:body

lambda          x\ λ    ["[" /[^\]]*/:outvars = "" "]"]
                        ["(" /[^\)]*/:invars = "" ")"]
                        S:body

meta            (none)  (none)
Results in a string containing only the escape character.

set-meta        (none)  H:escape
Sets the escape character to the given one.

bind            (none)  /[^#]+#/:name H:shortname
Binds the command whose name is name (without the trailing hash) to the
character specified by shortname.

ensemble-new    (none)  /[^#]+#/:name
Creates a new ensemble of the given name. An ensemble is a command which uses
the character following it to determine another command to delegate to. It is,
in essence, a secondary namespace for short commands. An ensemble is usable as
a normal command, including via #bind# etc.

ensemble-bind   (none)  /[^#]+#/:ensemble-name /[^#]+#/:command-name H:shortname
Binds command-name to shortname within the command ensemble-name, which must be
an ensemble (created by ensemble-new).

long-mode       (none)  ...:body
Sets the long-mode flag in the interpreter, and parses commands in Command mode
(which becomes Long mode due to the flag) until parsing is stopped. The
long-mode flag is then reset to what it was before the command was executed.

short-mode      (none)  ...:body
Like long-mode, but unsets the long-mode flag (thus body will be in normal
Command mode).

long-mode-cmd   (none)  /[a-zA-Z0-9_-]+/:name
Reads characters (including its own character) into a command name. That
command is then looked up and parsed, with the command character as the last
character in name.

FUNCTIONS

Functions are certain commands which:
+ Have no semantics based on their syntax;
+ Have no internal state.

These properties allow functions to be bound to various parameters at
run-time. Some commands can only work with functions. All user-defined commands
are functions and use the standard function syntax.

A function's parameters are generally expressed as
  (outputs <- inputs)

A function's first output is the actual result of the command. Secondary
outputs may be captured to registers or ignored.

Standard function syntax:
  [ "[" /[^\]]*/:outregs = "" "]" ] "(" (A:argument ["," A:argument [...]]) ")"
